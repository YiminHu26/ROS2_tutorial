////////////////////////////////////////////////////////////
02-002 Visualize a robot TFs in RViz2
# install urdf tutorial package
sudo apt install ros-jazzy-urdf-tutorial
source /opt/ros/jazzy/setup.bash
# or source .bashrc
# MUltiple udf models will be installed
cd /opt/ros/jazzy/share/urdf_tutorial/urdf

# launch a urdf model
ros2 launch urdf_tutorial display.launch.py model:=/opt/ros/jazzy/share/urdf_tutorial/urdf/08-macroed.urdf.xacro

/////////////////////////////////////////////////////////////
02-003 Relationship between TFs, TF Tree 
# There are arrows between "frames"/joints
# These shows how frames are placed relative to each other
# And how they move relative to each other
# while running the urdf in rviz
ros2 topic list
ros2 topic echo /tf
# And we will get the timesatamp, frame-id and translation and rotation (under header)

# We can visualize the TF tree
sudo apt install ros-jazzy-tf2-tools
source .bashrc

# while running the urdf in rviz
ros2 run tf2_tools view_frames
# It will generate a pdf file which presents the TF tree

///////////////////////////////////////////////////////////////
02-004 What problems are we trying to solve with TF
# Use TF tools to calculate transform
# We will create URDF file and use existing ROS packages
/////////////////////////////////////////////////////////////////
03-001 Intro-What is URDF
# Unified Robot Description Format: description of all elements in a robot

//////////////////////////////////////////////////////////////
03-002 Your First URDF file Create and Visulization
cd
touch my_robot.urdf
code my_robot.urdf
# by adding <?xml version="1.0"?>
# the file will be recognized as xml file in vscode

# link are the rigid parts of the robot
# use "visual" to define the shape and size of the object

ros2 launch urdf_tutorial display.launch.py model:=/home/yimin/ros2_ws/src/my_robot.urdf

////////////////////////////////////////////////////////////////
03-003 Material - Add some colors
# define the color and use them in <material>

/////////////////////////////////////////////////////////////////////
03-004 Combine 2 links with a joint
# After creating 2 links, create a joint and define the parent and child link to it
# Also modify the orientation of the joint and the link to have a correct visual
# In our example, a cylinder on a box and the joint should be on the bottom of the cylinder
# The origin of the cylinder is the relative coordinate to the origin of the joint

/////////////////////////////////////////////////////////////////////////////
03-005 ANother exampe of the process to write the URDF right the first time
# Here we created a another box and joint
# The box should be on top of the cylinder
# The orgin of the second_third joint is the relative coordinate to the base_second_joint
# and the origin of the box is the relative coordinate to the origin of the second_third_joint

//////////////////////////////////////////////////////////////////////////////
03-006 Different types of joints in a URDF
# Reference: https://wiki.ros.org/urdf/XML
# Here we will modify the joint type and relevant its elements
# joint type: 
# 1. revolute(rotation with limits, with axis, lower, upper, effort, velocity)
# 2. continuous(rotation without limits, with axis, without lower, upper, thus also without effort and velocity)
# 3. prismatic(translation with limits, with axis, lower, upper, effort, velocity)

///////////////////////////////////////////////////////////////////////
03-007 Add a WHeel to the robot
# Create a cylinder with a joint on the rear right, where the joint origin should be in the center of the wheel
# and the wheel should not intersect with the base box
# key: rpy of the link, xyz of the joint

//////////////////////////////////////////////////////////////////
03-008~009 Acitivity 01
# Task: to complete a URDF for a robot
# left and right wheels, caster wheel, base_footprint(global option - fixed frame - base_footprint)

//////////////////////////////////////////////////////////////////////
04-002 How the Robot State Publisher and URDF work together
# Open the robot urdf with rviz
ros2 launch urdf_tutorial display.launch.py model:=/home/yimin/ros2_ws/src/my_robot.urdf

# Output a pdf for the tf tree
ros2 run tf2_tools view_frames -o my_robot_frames

# View the topics and nodes
rqt_graph

ros2 topic list
# We will see 3 topics which also exist in the rqt_graph /robot_description, /joint_states and /tf
# It can be seen that it is the /robot_state_publisher node which publishes tfs
# so we dig deeper into it to see what is it publishing

ros2 params list /robot_state_publisher  
# where we get a parameter called robot_description
ros2 params get /robot_state_publisher robot_description
# we will get exactly the urdf file we wrote
# And this is also what is published in the /robot_description topic

# Besides the urdf, the /robot_State_publisher also takes in the data from the topic /joint_states (published by joint_state_publisher
ros2 topic echo /joint_states
# we will get the angle of the joints
# with the position data from urdf and robotion angle from joint states
# the /robot_state_publisher node can compute the tf
# And pass it to the tf topic

/joint_states --> /robot_state_publisher --> TF
			^
		      URDF or robot_description
////////////////////////////////////////////////////////////
04-003 Run the Robot State Publisher with URDF in the terminal
ros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:="$(xacro /home/yimin/ros2_ws/src/my_robot.urdf)"
		^			^
		pkg name		node name
(# to install xacro)
(sudo apt install ros-jazzy-xacro)
# After it shows "robot initialized" the node is started
ros2 node list
# and we can see the node robot_state_publisher

# we need the joint state as well
ros2 run joint_state_publisher_gui joint_state_publisher_gui 
(# to install joint state publisher gui)
(sudo apt install ros-jazzy-joint-state-publisher-gui)

# to visualize it
ros2 run rviz2 rviz2

# in RVIZ we will see nothing in the beginning
# we need to add the robot model and TF
# we need to set the fixed frame to base_footprint
# we need to description topic in robot model to /robot_description
#Then we will see the complete visualization
rqt_graph

# So in this lesson we learned to start the urdf without using the urdf tutorial file but simply in cli

//////////////////////////////////////////////
04-004 Create a Robot Description Packgage
mkdir ros2_ws
ls ros2_ws
mkdir src
sudo apt install ros-dev-tools
colcon build
source install/setup.bash
gedit ~/.bashrc
# Add a line in the end
source ~/ros2_ws/install/setup.bash
# ^ All steps above are initial setting for the folder

# Then we should create a package for the launch file
cd src
ros2 pkg create my_robot_description 
# "my_robot" can be replaced by the name of the robot
# This is the common way of naming the package
cd my_robot_description
rm -rf include/ src/
mkdir urdf

# Move the my_robot.urdf to the folder (the path can vary, depending on the place the urdf file is created
cd ..
mv my_robot.urdf my_robot_description/urdf/

cd
cd ros2_ws/src
code .

# Modify the Cmakelist file to add urdf to the DIRECTORY and share folder to the DESTINATION
# Save

cd ros2_Ws
colcon build

# We can find the urdf file in ros2_ws/install/my_robot_description/share/my_robot_description/urdf/my_robot.urdf
# We wont browse this path later, but it's good to know

///////////////////////////////////////////////////////////////
04-005 Write a Launch file to start th robot state publisher with urdf (XML)
# in ROS1 xml is used
# in ROS2 python is more popular as in documentation
# but it's way more complicated to write launch files in python
# good news is that we can include python in xml, as some function is limited in xml

# Normally we have to create dedicated folder for each robot, as they have different dependencies
# Here we will only have one
# Create a new folder launch/
# Create display.launch.xml
# add "launch" to CMakelist
-------------------------------
---Code refer to xml file---
-------------------------------

colcon build --packages-select my_robot_description
source install/setup.bash
ros2 launch my_robot_description display.launch.xml
# Modify the setting according to 04-003
rqt_graph

//////////////////////////////////////////////
04-006 Python Launch File
-------------------------------
---Code refer to py file---
-------------------------------

////////////////////////////////////////////////
04-007-008 Activity 02- Add Rviz config to the launch file
# First save the config(add robotmodel, add TF, change fixed frame, change description topic)
# Save it as urdf_config.rviz
# Put it in the rviz/ folder
mv urdf_config.rviz ros2_ws/src/my_robot_description/rviz/
# add rviz in CMakeList

# for xml file add args to the node
# for py file add arguments to the node

////////////////////////////////////////////////////////
05-002 Make the URDF compatible with Xacro
sudo apt install ros-jazzy-xacro
# Rename the urdf to .urdf.xacro (important is to have xacro in the end, urdf is not necessary)
-------------------------------
---Code refer to xacro file---
-------------------------------
# Add xmlns:xacro="http://www.ros.org/wiki/xacro"
# and change the name of the urdf in xml and py launch file

////////////////////////////////////
05-003 Create Vriables with xacro properties
# Instead of hardcoding the value of a variable,
# we can create a property in xacro
-------------------------------
---Code refer to xacro file---
-------------------------------
# And in Xacro we can use ${pi}

////////////////////////////////////////////////////////
05-004-005 Activity 03
# Basically we defined the length, width, height, radius, etc of the object in our urdf as parameters

//////////////////////////////////////////////////////////////////
05-006 Create Functions with Xacro Macros
# We can create macros as functions to compute the parameters automatically
# In our case we created macros to define left and right wheel link
# Here we used the parameter "prefix" to name the links differently
-------------------------------
---Code refer to xacro file---
-------------------------------

* Think twice before we use a macro. Because e.g. in our case we only have two links.
* It's kinda in the middle of using a macro and not.
* Sometimes "premature optimization is the root of all evil."

////////////////////////////////////////////////////////////////////
05-007 Include a Xacro File in another Xacro file
# Basically the method should be used in most of the project
# Because so far we put everything in one xacro file, which is also the main file
# When the robot comes with more components (camera, etc.), the file would be too long
# By splitting the main xacro file into several smaller files, the structure would be clearer.
# Here we split the xacro into "common properties.xacro" and "mobile_base.xacro"
# For each xacro file we need to have the header (but without the name, e.g "my robot" to distinguish it from the main file
# Those splitted files will be then included in the main file
-------------------------------
---Code refer to xacro file---
-------------------------------
# After coding we need to colcon build --symlink-install it again, because symlink doesnt include new files created

# One thing to notice is that the solution is not perfect
# We will use the color properties in the "common_properties" in "mobile_base"
# which means those two xacro always have to exist at the same time
# "common_properties" may also be used in other xacro files
# TO avoid including "common_properties" in each xacro file
# we MUST include it at the beginning of the main xacro file
# so that it can be used for all the following files

////////////////////////////////////////
05-008 The Xacro Command to generate the URDF
# In /launch/display_launch.xml, there is a command "xacro"
# It translates the xacro file to a urdf file
# because urdf is the parameter that the node robot_state_publisher takes

# it can be proved by 
ros2 launch my_robot_description display.launch.xml
ros2 param get /robot_state_publisher robot_description

# it says in the first line that this file is autogeneraed from the xacro file
# it is in urdf format
# we can see that all parameters are hardcoded

////////////////////////////////////////////
05-009 Real Meshes-quick overview
# So far we only used some basic object shapes
# IN real cases the shape are usally more complicated
# it should be made in CAD softwares

# it will be demonstrated in this lesson how we can import those meshes(models) in our urdf/xacro files
# we take the repo in github turtlebot3
https://github.com/ROBOTIS-GIT/turtlebot3/tree/jazzy
# In /turtle_description/urdf/ we have all the URDF files
# we can see that we imported some .stl files as meshes
# those .stl files are installed in /turtle_description/meshes

# what we need to do to use real meshes:
# 1. create a folder meshes under the description folder
# 2. include the meshes in CMakeList
# 3. import them in the urdf files
# 4. change the scale (usually the model is too big) and the orientation (rpy) if necessary

///////////////////////////////////////////////////////////
06-001 Gazebo Intro
# URDF vs Gazebo
# URDF: Visualization, debug (not simulation)
# Gazebo: Simulation (gravity, physics, as well as plugins to simulate hardware control of the robot)

//////////////////////////////////////////////////////////////
06-002 Run Gazebo
# Install Gazebo
sudo apt install ros-jazzy-ros-gz

////////////////////////////////////////////////////////////////////////
06-003 How Gazebo works with ROS
# It was introduced in this lesson how Gazebo and ros2 environment work together
# The structure of ros2 env can refer to 04-002
# There needs to be a ros2_gz_bridge between the two environments
# And in Gazebo we will have multiple plugins.

//////////////////////////////////////////////////////////////////////////////
06-004 Add inertial tags in the URDF
# Before we spawn the robot in Gazebo, we need to adapt the URDF model and add the inertial tags. Without those tags the model cannot exist in Gazebo.
# Reference: https://en.wikipedia.org/wiki/List_of_moments_of_inertia
# Reference: https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/Adding-Physical-and-Collision-Properties-to-a-URDF-Model.html
# 1. we create a macro for the box
# Because all boxes share the same formel for moment of inertia
# (In reality the models are not always of regular shapes. We can get the value from the CAD software where we import the mesh from)
# The macro should be created in common_properties.xacro, as the inertia formel is common and can be used not only for this robot. The xacro will than be used
-------------------------------
---Code refer to xacro file---
-------------------------------
# 2. build the pkg and launch the Rviz
ros2 launch my_robot_description display.launch.xml
# 3. UNCHECK RobotModel/Visul Enabled and TF
# Check RobotModel/MassProperties/Mass and Inertia
# If the visual and inertia correspond to the same thing, then the adaption is validated.

////////////////////////////////////////////////////////////////////////////////
06-005~006 Acitivity 04 - Inertia Macros
# In this activity we need to add the inertia for other components in our robot
# cylinder mass: 1.0kg
# sphere mass: 0.5kg

/////////////////////////////////////////////////////////////
06-007 Add Collision Tags in the URDF
# Besides the visual and inertial, we also need to add collision tags in the URDF
# In contrast to visual, where the mesh should be as detailed as possible, the collision shape should be as simple as possible (preferred: box, sphere, cylinder, etc., or you can create another simplied mesh in CAD software and include it in the collision tag) to simplify the calculation.
e.g.
<collision>
	<origin xyz="-0.064 0 0.0" rpy="0 0 0"/>
	<geometry>
		<mesh filename="package://turtlebot3_description/meshes/bases/waffle_base.stl" />
	</geometry>
</collision>
# Refer to turtlebot3 repo for collision tag details
-------------------------------
---Code refer to xacro file---
-------------------------------
# By checking RobotModel/Collision enabled, we can see the collision shape

//////////////////////////////////////////////////////////////
06-008 Spawn the robot in Gazebo
# IN this lesson 4 lines of command will be used (actually 3 + 1 for Rviz)
# 1. (in urdf folder)
ros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:="$(xacro my_robot.urdf.xacro)"
# 2. (here -r means to start the timer in gazebo as soon as it starts)
ros2 launch ros_gz_sim gz_sim.launch.py gz_args:="empty.sdf -r" 
# 3. (create a node)
ros2 run ros_gz_sim create -topic robot_description
# 4. (it's common that the wheels in rviz will disappear, reason is lack of plugins, will be solved in later sections)
ros2 run rviz2 rviz2 -d ros2_ws/src/my_robot_description/rviz/urdf_config.rviz

////////////////////////////////////////////////////////////////
06-009~110 Activity 05 Launch file to start the robot in Gazebo
1. Create a new package "my_robot_bringup"
2. Create and install a "launch" folder
# To create the package "my_robot_bringup" initally, refer to ros2_note.txt Line 997
3. Add a new launch file "my_robot_gazebo.launch.xml"
4. IN the launch file, start:
	-robot state publisher node
	-gazebo launch file
	-create node
	-Rviz2 with config
-------------------------------
---Code refer to xml file---
-------------------------------

# build the package and launch it
ros2 launch my_robot_bringup my_robot_gazebo.launch.xml 

//////////////////////////////////////////////////////////////////////////////
06-011 Add Gazebo Plugins to control the robot
# When we launched the robot in the last lesson, something was missing
ros2 topic list
ros2 topic echo /joint_states
# nothing would be returned.
# And there was also no topics like cmd_vel which usually send command to the robot
# when we use rqt_graph we can see that nothing is publishing to the topic /joint_states
# TO solve this we need to add plugins and add gazebo bridge.
Reference: https://github.com/gazebosim/gz-sim/tree/gz-sim10
# we will add 2 plugins in this lesson: DiffDrive and JointStatePublisher
# we will not directly add gazebo tags in the mobile_base.xacro
# instead we create a new mobile_base_gazebo.xacro
# we should give the "filename" and the "name"
# the plugin filename should be "gz-sim-<plugin name in the github with lower case and separated by dash>-system
# e.g for DiffDrive => gz-sim-diff-drive-system
# the name can be found at the end of the .cc file(here https://github.com/gazebosim/gz-sim/blob/gz-sim10/src/systems/diff_drive/DiffDrive.cc)
# Then we also need to define several parameters according to the .hh file (left_joint, right_joint, wheel_separation, etc.)
# frame_id(odon) and child_frame_id(base_footprint) basically related to the wheel velocity and tf between the two frames(location)

# Then we add JointStatePublisher
# so that the state can be returned back into ros2
# we have a fake joint state publisher in our launch file (...gui) we wont use it any more
# we will use later the gazebo one, which is going to simulate a hardware(wheel encoder in this case)
# actually the states will be published only in gazebo, that's why we need a bridge later

# One last thing, the caster wheel
# The caster wheel is in our case a passive wheel/fixed joint. To make it move as smooth as possible and not to collide with the ground, we will add friction coefficience.

///////////////////////////////////////////////////////////////////////////////////////
06-012 Set up the Gazebo Bridge
# For now gazebo and rviz2(ros2) still cannot communicate with each other
# we will set up the bridge(special nodes as topics) between them

# First we can have a overview of what topics exist in ros2 and gazebo, when we launch the robot (remember to colcon build)
ros2 launch my_robot_bringup my_robot_gazebo.launch.xml
ros2 topic list
gz topic -l
# we will bridge 5 topics to ros2 (clock, odometry, joint_state, tf, cmd_vel)

# go to my_robot_gazebo.launch.xml
# add the following node
<node pkg="ros_gz_bridge" exec="parameter_bridge" >
          <param name="config_file" value="" />>
</node>
# and include the executable in the package.xml
# the config file should be in its folder my_robot_bringup/config
# remember to add it to the INSTALL in Cmakelist
# add the followiing line to the launch xml
    <let name="gazebo_config_path"
        value="$(find-pkg-share my_robot_bringup)/config/gazebo_bridge.yaml" />
    ...

# in the yaml file
- ros_topic_name: from topic list or create a new one
  gz_topic_name: from topic list or create a new one
  ros_type_name:
  gz_type_name:
  direction: <GZ_TO_ROS> / <ROS_TO_GZ> / BIDRECTIONAL
  
# to see the topic type, here e.g. /clock
gz topic -i -t /clock #-i for information, -t for topic
# it returns
>	gz.msgs.Clock
# this will be the gazebo type
# for the ros type : https://github.com/gazebosim/ros_gz/tree/ros2/ros_gz_bridge

#NOTE:
# 1 joint state also exist in ros2, but it is empty
# we will pass the value in gazebo topic joint_state to ros2 with the bridge, so the topic name in ros needs to be exactly the same as it originally was

# 2 as we mentioned before, the plugin diff_drive will create an extra link between oden and base_footprint, which does not exist in ros but only in gazebo, this link will be passed through the tf topic

# 3 and the cmd_vel has not been mapped. we will map it with ros2, the command come from ros to gazebo

/////////////////////////////////////////////////////////////////////////
06-013 Final result and debugging
colcon build --packages-select my_robot_bringup my_robot_description
ros2 launch my_robot_bringup my_robot_gazebo.launch.xml
# the robot will be spawned in gazebo
# and a corresponding model exist in rviz

# we can play around it
rqt_graph
ros2 run tf2_tools view_frames
ros2 topic echo /joint_states # where we can see the response from the left and right joint

# we can even publish command
ros2 topic info /cmd_vel
>	Type: geometry_msgs/msg/Twist
ros2 interface show geometry_msgs/msg/Twist
>	Vector3  linear
		float64 x
		float64 y
		float64 z
	Vector3  angular
		float64 x
		float64 y
		float64 z
ros2 topic pub -r 1 /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.5}, angular: {z: 0.5}}"
# The robot will start moving , x means the robot can only move forwards and backwards, z means the rotation on z axis
# TO stop the activity, we have to publish again with 0 for x and 0 for z

# *teleoperation
ros2 run teleop_twist_keyboard teleop_twist_keyboard
# control the car with uio jkl m<> (remember to have the terminator in the front)

//////////////////////////////////////////////////////////////////////////////
06-014 Create a World in Gazebo
# Resource spawner: browse in https://app.gazebosim.org/OpenRobotics and directly search for the models in Gazebo
# ^^^ That was only for models from the organization OpenRobotics
# TO add from other organization, either create a new folder with the name of its organization
# or go to this website and download the model, exatract it, locate the dae file
# in gazebo entity tree, "+" meshes and place it

# TO perfectly replicate the environment, use blender or solidworks ...

# To save the environment, first remove the robot(right click-remove)
# Menu-save world as-name it with .sdf extention-leave boxes unchecked
# start it again
gz sim <name>

////////////////////////////////////////////////////////////////////////////////////
06-015 Launch the robot in the world
# 1 store the environment file under my_robot_bringup/worlds/test_world.sdf
# 2 In CMakeLists add worlds to install
# 3 In my_robot_gazebo.launch xml replace empty.sdf with the current environment
# 4 colcon build
# 5 ros2 launch my_robot_bringup my_robot_gazebo.launch.xml
# 6 ros2 run teleop_twist_keyboard teleop_twist_keyboard

# The robot will be spawned in the environment and can be controlled by the keyboard
# the sdf file can be modified manually as well (for example to place some object fixed in their position, 
# we may need to first import them into the entity tree and then modify soe parameters in the sdf file)

/////////////////////////////////////////////////////////////////////////////////////////////
07-002 Add a Camera to the URDF
# we basically create a new xacro file for the camera, where a new link and joint related to the camera is created

//////////////////////////////////////////////////////////////////////////////////////////////
07-003 Add a Gazebo PLugin for the camera
# in this lesson we added a sensor plugin to the gazebo, and bridge the gazebo topic to rviz, so that we can directly visualize the camera in rviz

# 1 In "test_world.sdf", add sensor plugin (line 12-14)
# 2 In "camera.xacro" add a new gazebo tag (where the two topics "camera/camera_info" and "camera/image_raw" exist, can also be checked by "gz topic -l" after running "ros2 launch my_robot_bringup my_robot_gazebo.launch.xml"
# 3 Bridge the topics (refer to 06-012)
# 4 Launch the ros again (validate that ROS also has camera topics now by "ros2 topic list"
# 5 IN Rviz, click add-camera-topic:camera/image/raw
(Somehow there's a blue occludor in front of the camera, probably the blue tf)

//////////////////////////////////////////////////////////////////////////////////////////////////////
07-004 Optional QUick fix for the camera to work with ROS
# Actually with OpenCV, as the coordinate convention of OpenCV is different from RViz)

///////////////////////////////////////////////////////////////////
08 Final Project
# with arm alone
ros2 topic pub -1 /joint0/cmd_pos std_msgs/msg/Float64  "{data: 0.5}"
ros2 topic pub -1 /joint1/cmd_pos std_msgs/msg/Float64  "{data: 0.5}"

or publish to /set_joint_trajectory



